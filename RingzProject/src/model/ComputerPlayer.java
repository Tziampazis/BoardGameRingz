package model;

import java.util.List;
import java.util.Observable;
import java.util.Random;

/**
 * The ComputerPlayer class is the class that extends Player and gets the move by random from the computer. The command
 * that is generated by random is coded using an int array and is passing through player class.
 * 
 * @author Christodoulos Tziampazis & Mihai Marin
 * @version 1.0
 * @since 2018-01-15
 */
public class ComputerPlayer extends Player{

	public static Random random = new Random();

	/**
	 * Constructor that calls the constructor of the player using super.
	 * @param name The name of the player.
	 * @param bases Bases of the player.
	 * @param rings Rings of the player.
	 * @param colours Colours of the player.
	 */
	public ComputerPlayer(String name, List<Base> bases, List<Ring> rings, List<Colour> colours) {
		super(name, bases, rings, colours);
	}

	/**
	 * This method returns an int array containing the encoded move. The move is generated totally by random.
	 */
	public int[] determineMove(Board board) {
		int[] choice = new int[4];
		boolean valid = false;
		do{
			int piece = getRandomNumberInRange(0,1);
			int colour = getRandomNumberInRange(1,4);
			int size = getRandomNumberInRange(1,4);
			int index = getRandomNumberInRange(0,24);
			choice[0] = piece;
			choice[1] = colour;
			choice[2] = size;
			choice[3] = index;
			if(piece == 0) {
				Base base = new Base(intToColour(colour));
				valid = board.isValidMoveBase(base, index) && hasColour(intToColour(colour)) && hasBase(intToColour(colour));
				if(valid){
					System.out.println("Basepiece : "+choice[0]+ " colour: " +choice[1] +  " size: "+ choice[2] +" index: " + choice[3]);
				}
			} else if(piece == 1) {
				Ring ring = new Ring(intToColour(colour), intToSize(size));
				valid = board.isValidMoveRing(ring, index) && hasColour(intToColour(colour)) && hasRing(intToColour(colour), intToSize(size));
				if(valid){
					System.out.println("Ringpiece : "+choice[0]+ " colour: " +choice[1] +  " size: "+ choice[2] +" index: " + choice[3]);
				}
			}
		} while(!valid);

		System.out.println("Computer made move: " + choice[0] + choice[1] + choice[2] + choice[3]);
		return choice;
	}

	/**
	 * This method returns an int representing the territory index for the starting base.
	 * This number is generated by random.
	 */
	public int determineStartBase(Board board) {
		int choice = getRandomNumberInRange(6,18);
		boolean valid = board.canPlaceStartBase(choice);
		while(!valid) {
			choice = getRandomNumberInRange(6,18);
			valid = board.canPlaceStartBase(choice);
		}
		return choice;
	}

	/**
	 * Method that generates a random number in a given interval including margins.
	 * @param min The minimum number. Left side of the interval.
	 * @param max The maximum number. Right side of the interval.
	 * @return A random int in the given interval.
	 */
	private static int getRandomNumberInRange(int min, int max) {

		if (min >= max) {
			throw new IllegalArgumentException("max must be greater than min");
		}

		Random r = new Random();
		return r.nextInt((max - min) + 1) + min;
	}

	@Override
	public void update(Observable o, Object arg) {
		// TODO Auto-generated method stub
		
	}
}
